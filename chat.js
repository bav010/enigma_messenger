const CLIENT_VERSION = "1.0.3";

let peer;
let myId = null;
let sharedKey = null;
const connections = new Map(); // peerId -> DataConnection
const messageHistory = new Map(); // peerId -> [messages]

const usernameEl = document.getElementById("username");
const passwordEl = document.getElementById("password");
const authStatusEl = document.getElementById("authStatus");
const authContainer = document.getElementById("authContainer");
const chatContainer = document.getElementById("chatContainer");
const myIdEl = document.getElementById("my-id");
const copyIdBtn = document.getElementById("copyIdBtn");
const connectToEl = document.getElementById("connectTo");
const msgInput = document.getElementById("msgInput");
const sendBtn = document.querySelector("button[onclick='sendMsg()']");
const chatLog = document.getElementById("chatLog");
const keyInput = document.getElementById("keyInput");
const cipherSelect = document.getElementById("cipherSelect");
const keyStatus = document.getElementById("keyStatus");
const connectionStatus = document.getElementById("connectionStatus");
const chatListItems = document.getElementById("chatListItems");

let currentPeer = null;

function saveHistoryToStorage() {
  const history = {};
  for (let [peerId, messages] of messageHistory.entries()) {
    history[peerId] = messages;
  }
  localStorage.setItem("chat-history-" + myId, JSON.stringify(history));
}

function loadHistoryFromStorage() {
  const raw = localStorage.getItem("chat-history-" + myId);
  if (!raw) return;
  try {
    const history = JSON.parse(raw);
    for (let peerId in history) {
      messageHistory.set(peerId, history[peerId]);
      addToChatList(peerId);
    }
  } catch {}
}

function deleteChat(peerId) {
  messageHistory.delete(peerId);
  saveHistoryToStorage();
  const li = [...chatListItems.children].find(li => li.dataset.peerId === peerId);
  if (li) li.remove();
  if (currentPeer === peerId) {
    currentPeer = null;
    chatLog.value = "";
    msgInput.disabled = true;
    sendBtn.disabled = true;
    connectionStatus.textContent = "üì≠ –ß–∞—Ç —É–¥–∞–ª—ë–Ω";
  }
}

function log(message, outgoing = false, peerId = currentPeer) {
  if (!peerId) {
    console.error("–ü–æ–ø—ã—Ç–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –±–µ–∑ peerId");
    return;
  }
  
  const prefix = outgoing ? '>> ' : '<< ';
  const formatted = `${prefix}${message}\n`;
  
  console.log(`–õ–æ–≥–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è ${peerId}: ${formatted.trim()}`);
  
  if (!messageHistory.has(peerId)) {
    messageHistory.set(peerId, []);
    console.log(`–°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –∏—Å—Ç–æ—Ä–∏—è –¥–ª—è ${peerId}`);
  }
  
  messageHistory.get(peerId).push(formatted);
  
  // –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ —Ç–µ–∫—É—â–∏–π —á–∞—Ç
  if (peerId === currentPeer) {
    chatLog.value += formatted;
    chatLog.scrollTop = chatLog.scrollHeight;
    console.log(`–û–±–Ω–æ–≤–ª–µ–Ω –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å —á–∞—Ç–∞ –¥–ª—è ${peerId}`);
  } else {
    console.log(`–°–æ–æ–±—â–µ–Ω–∏–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–æ –¥–ª—è ${peerId}, –Ω–æ –Ω–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–æ (—Ç–µ–∫—É—â–∏–π —á–∞—Ç: ${currentPeer})`);
  }
  
  saveHistoryToStorage();
}

async function register() {
  const username = usernameEl.value.trim();
  const password = passwordEl.value.trim();
  if (!username || !password) {
    authStatusEl.textContent = "–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å";
    return;
  }

  try {
    const res = await fetch("/register", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password })
    });

    const data = await res.json();
    if (!res.ok) throw new Error(data.message);
    authStatusEl.textContent = "‚úÖ –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞. –¢–µ–ø–µ—Ä—å –≤–æ–π–¥–∏—Ç–µ.";
  } catch (e) {
    authStatusEl.textContent = "‚ùå " + e.message;
  }
}

async function login() {
  const username = usernameEl.value.trim();
  const password = passwordEl.value.trim();

  if (!username || !password) {
    authStatusEl.textContent = "–í–≤–µ–¥–∏—Ç–µ –ª–æ–≥–∏–Ω –∏ –ø–∞—Ä–æ–ª—å";
    return;
  }

  try {
    const res = await fetch("/login", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ username, password })
    });

    const data = await res.json();
    if (!res.ok) throw new Error(data.message);

    startPeer(username, data.peerId);
  } catch (e) {
    authStatusEl.textContent = "‚ùå " + e.message;
  }
}

function startPeer(username, suggestedId) {
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –æ–∫—Ä—É–∂–µ–Ω–∏—è
  const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  
  const peerConfig = {
    host: location.hostname,
    path: "/peerjs",
    secure: location.protocol === 'https:',
    debug: 2 // –í–∫–ª—é—á–∞–µ–º –æ—Ç–ª–∞–¥–∫—É –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
  };

  // –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è —É–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Ä—Ç
  if (isLocalhost) {
    peerConfig.port = location.port || (location.protocol === 'https:' ? 443 : 80);
  }
  // –î–ª—è –ø—Ä–æ–¥–∞–∫—à–µ–Ω–∞ (Render) –ø–æ—Ä—Ç –Ω–µ —É–∫–∞–∑—ã–≤–∞–µ–º - –±—É–¥–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π

  console.log('PeerJS config:', peerConfig);

  peer = new Peer(suggestedId || undefined, peerConfig);

  peer.on("open", async id => {
    console.log('PeerJS connected with ID:', id);
    myId = id;
    myIdEl.textContent = id;
    authContainer.style.display = "none";
    chatContainer.style.display = "flex";
    connectionStatus.textContent = "‚úÖ –ì–æ—Ç–æ–≤ –∫ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—é...";
    loadHistoryFromStorage();

    try {
      await fetch("/updatePeerId", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, peerId: id })
      });
    } catch (e) {
      console.error("–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å peerId –Ω–∞ —Å–µ—Ä–≤–µ—Ä–µ", e);
    }

    fetch("version.json").then(r => r.json()).then(({ version }) => {
      if (version !== CLIENT_VERSION) {
        alert(`–î–æ—Å—Ç—É–ø–Ω–∞ –Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è —á–∞—Ç–∞: ${version}`);
        location.reload();
      }
    }).catch(() => {});
  });

  peer.on("connection", conn => {
    console.log(`–í—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç ${conn.peer}`);
    if (conn.peer === myId) return;
    
    conn.on("open", () => {
      console.log(`–í—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ –æ—Ç ${conn.peer}`);
      setupConnection(conn);
    });
  });

  peer.on("disconnected", () => {
    console.warn("‚ö†Ô∏è PeerJS: disconnected");
    connectionStatus.textContent = "‚ö†Ô∏è –ü–æ—Ç–µ—Ä—è–Ω–æ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–µ—Ä–≤–µ—Ä–æ–º PeerJS";
    
    // –ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è —á–µ—Ä–µ–∑ 3 —Å–µ–∫—É–Ω–¥—ã
    setTimeout(() => {
      if (peer.disconnected) {
        console.log("–ü–æ–ø—ã—Ç–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è...");
        peer.reconnect();
      }
    }, 3000);
  });

  peer.on("error", err => {
    console.error("PeerJS error:", err);
    let errorMessage = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞";
    
    if (err.type === 'network') {
      errorMessage = "–û—à–∏–±–∫–∞ —Å–µ—Ç–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç—É";
    } else if (err.type === 'peer-unavailable') {
      errorMessage = "–°–æ–±–µ—Å–µ–¥–Ω–∏–∫ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω";
    } else if (err.type === 'server-error') {
      errorMessage = "–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ PeerJS";
    }
    
    alert("–û—à–∏–±–∫–∞ PeerJS: " + errorMessage);
    connectionStatus.textContent = "‚ùå " + errorMessage;
  });
}

function connectToPeer() {
  const peerId = connectToEl.value.trim();
  if (!peerId || peerId === myId) return alert("–ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —Å–µ–±–µ");
  if (connections.has(peerId)) return switchChat(peerId);

  console.log(`–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ ${peerId}`);
  const conn = peer.connect(peerId);

  conn.on("open", () => {
    console.log(`–ò—Å—Ö–æ–¥—è—â–µ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ —Å ${peerId}`);
    setupConnection(conn);
  });

  conn.on("error", err => {
    console.error("–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è:", err);
    alert("–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ " + peerId);
  });
}

function setupConnection(conn) {
  const peerId = conn.peer;

  conn.on("open", () => {
    console.log(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –æ—Ç–∫—Ä—ã—Ç–æ —Å ${peerId}`);
    connections.set(peerId, conn);
    addToChatList(peerId);
    
    // –í–°–ï–ì–î–ê –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –Ω–æ–≤—ã–π —á–∞—Ç –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
    switchChat(peerId);
    
    log("üîó –°–æ–µ–¥–∏–Ω–µ–Ω–æ —Å " + peerId, false, peerId);
    conn.send({ type: "version", version: CLIENT_VERSION });
  });

  conn.on("data", async data => {
    console.log(`–ü–æ–ª—É—á–µ–Ω—ã –¥–∞–Ω–Ω—ã–µ –æ—Ç ${peerId}:`, data);
    
    if (typeof data === "object" && data.type === "version") {
      if (data.version !== CLIENT_VERSION) {
        log(`‚ö†Ô∏è –£ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞ –≤–µ—Ä—Å–∏—è ${data.version}`, false, peerId);
      }
      return;
    }

    // –†–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ
    let message = data;
    if (cipherSelect.value === "aes" && sharedKey) {
      try {
        message = await decryptMessage(data);
      } catch (e) {
        console.error("–û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏:", e);
        log("‚ùå –û—à–∏–±–∫–∞ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏", false, peerId);
        return;
      }
    }
    
    // –ï—Å–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —á–∞—Ç–∞, –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è
    if (!currentPeer) {
      console.log(`–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ —á–∞—Ç —Å ${peerId}`);
      switchChat(peerId);
    }
    
    // –õ–æ–≥–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    log(message, false, peerId);
    
    // –ï—Å–ª–∏ —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ –æ—Ç —Ç–µ–∫—É—â–µ–≥–æ –∞–∫—Ç–∏–≤–Ω–æ–≥–æ —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–∞, –ø–æ–∫–∞–∑–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ
    if (currentPeer !== peerId) {
      console.log(`–ù–æ–≤–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç ${peerId}: ${message}`);
      
      // –î–æ–±–∞–≤–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–π –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
      const chatItem = [...chatListItems.children].find(li => li.dataset.peerId === peerId);
      if (chatItem) {
        chatItem.style.fontWeight = 'bold';
        chatItem.style.backgroundColor = '#e3f2fd';
      }
    }
  });

  conn.on("close", () => {
    console.log(`–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ —Å ${peerId}`);
    connections.delete(peerId);
    if (currentPeer === peerId) {
      log("üîå –ß–∞—Ç –∑–∞–∫—Ä—ã–ª—Å—è: " + peerId, false, peerId);
      connectionStatus.textContent = "‚ùå –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∑–∞–∫—Ä—ã—Ç–æ";
      msgInput.disabled = true;
      sendBtn.disabled = true;
    }
  });

  conn.on("error", (err) => {
    console.error(`–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å ${peerId}:`, err);
  });
}

function switchChat(peerId) {
  if (!connections.has(peerId) && !messageHistory.has(peerId)) return;
  
  currentPeer = peerId;
  connectionStatus.textContent = "üí¨ –û–±—â–µ–Ω–∏–µ —Å " + peerId;
  msgInput.disabled = false;
  sendBtn.disabled = false;
  
  // –û—á–∏—Å—Ç–∏—Ç—å –≤–∏–∑—É–∞–ª—å–Ω—ã–µ –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä—ã –Ω–µ–ø—Ä–æ—á–∏—Ç–∞–Ω–Ω—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
  const chatItem = [...chatListItems.children].find(li => li.dataset.peerId === peerId);
  if (chatItem) {
    chatItem.style.fontWeight = 'normal';
    chatItem.style.backgroundColor = 'transparent';
  }
  
  // –ó–∞–≥—Ä—É–∑–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é —á–∞—Ç–∞
  chatLog.value = "";
  const history = messageHistory.get(peerId) || [];
  chatLog.value = history.join("");
  chatLog.scrollTop = chatLog.scrollHeight;
  
  console.log(`–ü–µ—Ä–µ–∫–ª—é—á–∏–ª—Å—è –Ω–∞ —á–∞—Ç —Å ${peerId}, –∏—Å—Ç–æ—Ä–∏—è: ${history.length} —Å–æ–æ–±—â–µ–Ω–∏–π`);
}

function sendMsg() {
  const msg = msgInput.value.trim();
  if (!msg || !currentPeer) return;

  const conn = connections.get(currentPeer);
  if (!conn?.open) {
    alert("–°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫–æ–º –ø–æ—Ç–µ—Ä—è–Ω–æ");
    return;
  }

  console.log(`–û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ "${msg}" –¥–ª—è ${currentPeer}`);

  if (cipherSelect.value === "aes" && sharedKey) {
    encryptMessage(msg).then(enc => {
      conn.send(enc);
      console.log("–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ");
    }).catch(err => {
      console.error("–û—à–∏–±–∫–∞ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:", err);
      alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è");
    });
  } else {
    conn.send(msg);
    console.log("–ù–µ–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ");
  }
  
  log(msg, true);
  msgInput.value = "";
}

function deriveKey() {
  const password = keyInput.value;
  if (!password) return alert("–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å –¥–ª—è –∫–ª—é—á–∞");

  const enc = new TextEncoder();
  window.crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]).then(baseKey => {
    return window.crypto.subtle.deriveKey({
      name: "PBKDF2",
      salt: enc.encode("peerjs-chat"),
      iterations: 100000,
      hash: "SHA-256"
    }, baseKey, { name: "AES-GCM", length: 128 }, false, ["encrypt", "decrypt"]);
  }).then(key => {
    sharedKey = key;
    keyStatus.textContent = "üîê –ö–ª—é—á —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω";
  }).catch(() => alert("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–ª—é—á–∞"));
}

async function encryptMessage(message) {
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const enc = new TextEncoder().encode(message);
  const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, sharedKey, enc);
  return { iv: Array.from(iv), data: Array.from(new Uint8Array(ciphertext)) };
}

async function decryptMessage({ iv, data }) {
  const buffer = new Uint8Array(data);
  const ivArray = new Uint8Array(iv);
  const decrypted = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: ivArray }, sharedKey, buffer);
  return new TextDecoder().decode(decrypted);
}

function addToChatList(peerId) {
  if ([...chatListItems.children].some(li => li.dataset.peerId === peerId)) return;

  const li = document.createElement("li");
  li.dataset.peerId = peerId;
  li.style.display = "flex";
  li.style.justifyContent = "space-between";
  li.style.alignItems = "center";
  li.style.padding = "4px 0";

  const nameSpan = document.createElement("span");
  nameSpan.textContent = peerId;
  nameSpan.style.cursor = "pointer";
  nameSpan.onclick = () => {
    console.log(`–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ —á–∞—Ç —Å ${peerId} –ø–æ –∫–ª–∏–∫—É`);
    switchChat(peerId);
  };

  const delBtn = document.createElement("button");
  delBtn.innerHTML = "&times;";
  delBtn.title = "–£–¥–∞–ª–∏—Ç—å —á–∞—Ç";
  delBtn.style.border = "none";
  delBtn.style.background = "transparent";
  delBtn.style.cursor = "pointer";
  delBtn.style.fontSize = "14px";
  delBtn.style.color = "#999";
  delBtn.style.width = "20px";
  delBtn.style.height = "20px";
  delBtn.style.lineHeight = "20px";
  delBtn.style.textAlign = "center";
  delBtn.style.borderRadius = "4px";

  delBtn.onmouseenter = () => delBtn.style.color = "#d00";
  delBtn.onmouseleave = () => delBtn.style.color = "#999";
  delBtn.onclick = (e) => {
    e.stopPropagation();
    deleteChat(peerId);
  };

  li.appendChild(nameSpan);
  li.appendChild(delBtn);
  chatListItems.appendChild(li);
  
  console.log(`–î–æ–±–∞–≤–ª–µ–Ω –≤ —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤: ${peerId}`);
}

function clearChatList() {
  chatListItems.innerHTML = "";
}

// –î–æ–±–∞–≤–ª—è–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è Enter –≤ –ø–æ–ª–µ —Å–æ–æ–±—â–µ–Ω–∏—è
msgInput.addEventListener('keypress', function(e) {
  if (e.key === 'Enter') {
    sendMsg();
  }
});

copyIdBtn.onclick = () => {
  navigator.clipboard.writeText(myId).then(() => {
    copyIdBtn.textContent = "‚úÖ";
    setTimeout(() => copyIdBtn.textContent = "üìã", 1000);
  });
};